#!/bin/bash -e
# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This script defines a git subcommand that manages a set of fork repositories
# tracked inside of the repository itself.
#
# The list of forks is stored in the ref "refs/devtools/forks".
#
# That ref holds a commit whose tree contains separate directories for each
# fork. These subdirectories provide the fork's name and a list of its URLs.
#
# The directory name for each fork is generated by calling `git hash-object`
# on the name of the fork and then splitting the hash into three subpaths
# consistenting of the first character, the second character, and the remaining
# characters.
#
# Under each subtree there is a single blob named "NAME" whose contents are the
# name of the fork, and a subtree named "URLS" whose files specify URLs for the
# fork.
#
# So, for example, if a fork is named "builder", then the hash would be
# "722e59f54066747dcc720b2d059cf9c283ada3f9", and the corresponding subtree
# would be "7/2/2e59f54066747dcc720b2d059cf9c283ada3f9".
#
# If that fork had a single URL of "https://example.com/repo", then that URL
# would hash to "cfb403c9a1ca4506fc890435681f04dfaf209674".
#
# In this example, the output of running `git ls-tree -r refs/devtools/forks`
# would include the following lines:
#
#	100644 blob 722e59f54066747dcc720b2d059cf9c283ada3f9	7/2/2e59f54066747dcc720b2d059cf9c283ada3f9/NAME
#	100644 blob cfb403c9a1ca4506fc890435681f04dfaf209674	7/2/2e59f54066747dcc720b2d059cf9c283ada3f9/URLS/cfb403c9a1ca4506fc890435681f0dfaf209674
#
# This format was chosen to prevent merge conflicts. As a result, this list
# of forks can be pulled from a remote repository without manual intervention.

sep=$'\n'
tab=$'\t'

function add_to_tree {
  type="${1}"
  obj="${2}"
  name="${3}"
  current_tree="${4}"
  case "${type}" in
    blob)
      mode="100644"
      ;;
    *)
      mode="040000"
      ;;
  esac
  if [[ -n "${current_tree}" ]]; then
    filtered_tree_contents="$(git ls-tree "${current_tree}" | grep -v "${tab}${name}")"
  fi
  if [[ -n "${filtered_tree_contents}" ]]; then
    tree_hash=$(echo "${filtered_tree_contents}${sep}${mode} ${type} ${obj}${tab}${name}" | git mktree)
  else
    tree_hash=$(echo "${mode} ${type} ${obj}${tab}${name}" | git mktree)
  fi
  echo "${tree_hash}"
}

function remove_from_tree {
  name="${1}"
  current_tree="${2}"
  filtered_tree_contents="$(git ls-tree "${current_tree}" | grep -v "${tab}${name}")"
  if [[ -z "${filtered_tree_contents}" ]]; then
    return
  fi

  tree_hash=$(echo "${filtered_tree_contents}" | git mktree)
  echo "${tree_hash}"
}

function recursive_add_to_tree {
  type="${1}"
  obj="${2}"
  path="${3}"
  current_tree="${4}"

  name="$(echo "${path}" | cut -d '/' -f 1)"
  rest="${path:${#name}}"
  subpath="${rest:1}"
  if [[ -z "${subpath}" ]]; then
    add_to_tree "${type}" "${obj}" "${path}" "${current_tree}"
    return
  fi

  if [[ -n "${current_tree}" ]]; then
    prior_subtree=$(git ls-tree "${current_tree}" "${name}" | cut -d $'\t' -f 1 | cut -d ' ' -f 3)
  fi
  subtree=$(recursive_add_to_tree "${type}" "${obj}" "${subpath}" "${prior_subtree}")
  add_to_tree "tree" "${subtree}" "${name}" "${current_tree}"
}

function recursive_remove_from_tree {
  path="${1}"
  current_tree="${2}"
  if [[ -z "${current_tree}" ]]; then
    return
  fi

  name="$(echo "${path}" | cut -d '/' -f 1)"
  rest="${path:${#name}}"
  subpath="${rest:1}"

  curr_obj=$(git ls-tree "${current_tree}" "${name}" | cut -d $'\t' -f 1 | cut -d ' ' -f 3)
  if [[ -z "${curr_obj}" ]]; then
    echo "${current_tree}"
    return
  fi

  if [[ -z "${subpath}" ]]; then
    remove_from_tree "${name}" "${current_tree}"
    return
  fi

  updated_subtree=$(recursive_remove_from_tree "${subpath}" "${curr_obj}")
  if [[ -z "${updated_subtree}" ]]; then
    remove_from_tree "${name}" "${current_tree}"
    return
  fi
  add_to_tree "tree" "${updated_subtree}" "${name}" "${current_tree}"
}

function add_fork {
  name="${1}"
  url="${2}"
  owners="${3}"
  if [[ -z "${name}" || -z "${url}" ]]; then
    echo "You must specify the fork to add, and the URL for that fork" >&2
    echo "" >&2
    echo "Usage: git fork add [-o <owner-email>]* <name> <URL>" >&2
    exit 1
  fi
  echo "Adding the fork ${name} (${url})" >&2

  current_forks_commit="$((git show-ref refs/devtools/forks || true) | cut -d ' ' -f 1)"

  name_hash="$(echo "${name}" | git hash-object -w --stdin)"
  url_hash="$(echo "${url}" | git hash-object -w --stdin)"
  fork_path="${name_hash:0:1}/${name_hash:1:1}/${name_hash:2}"
  name_path="${fork_path}/NAME"
  url_path="${fork_path}/URLS/${url_hash}"

  updated_forks_tree=$(recursive_add_to_tree "blob" "${name_hash}" "${name_path}" "${current_forks_commit}")
  updated_forks_tree=$(recursive_add_to_tree "blob" "${url_hash}" "${url_path}" "${updated_forks_tree}")
  for refspec in \
    "refs/heads/${name}/*:refs/heads/${name}/*" \
    "refs/tags/${name}/*:refs/tags/${name}/*" \
    "refs/notes/devtools/*:refs/notes/forks/${name}/devtools/*" \
    "refs/devtools/*:refs/forks/${name}/devtools/*"; do
    refspec_hash="$(echo "${refspec}" | git hash-object -w --stdin)"
    refspec_path="${fork_path}/REFSPECS/${refspec_hash}"
    updated_forks_tree=$(recursive_add_to_tree "blob" "${refspec_hash}" "${refspec_path}" "${updated_forks_tree}")
  done

  for owner in ${owners}; do
    refspec="refs/notes/devtools/*:refs/notes/forks/${owner}/devtools/*"
    refspec_hash="$(echo "${refspec}" | git hash-object -w --stdin)"
    refspec_path="${fork_path}/REFSPECS/${refspec_hash}"
    updated_forks_tree=$(recursive_add_to_tree "blob" "${refspec_hash}" "${refspec_path}" "${updated_forks_tree}")
  done

  if [[ -z "${current_forks_commit}" ]]; then
    new_forks_commit=$(git commit-tree -m "Adding the fork ${name} (${url})" "${updated_forks_tree}")
    git update-ref "refs/devtools/forks" "${new_forks_commit}"
  else
    new_forks_commit=$(git commit-tree -p "${current_forks_commit}" -m "Adding the fork ${name} (${url})" "${updated_forks_tree}")
    git update-ref "refs/devtools/forks" "${new_forks_commit}" "${current_forks_commit}"
  fi
}

function remove_fork {
  name="${1}"
  if [[ -z "${name}" ]]; then
    echo "You must specify the fork to remove" >&2
    echo "" >&2
    echo "Usage: git fork remove <name>" >&2
    exit 1
  fi
  echo "Removing the fork ${name}" >&2

  name_hash="$(echo "${name}" | git hash-object -w --stdin)"
  fork_path="${name_hash:0:1}/${name_hash:1:1}/${name_hash:2}"

  current_forks_commit="$((git show-ref refs/devtools/forks || true) | cut -d ' ' -f 1)"
  current_forks_tree="$((git cat-file -p refs/devtools/forks 2>/dev/null || true) | grep '^tree ' | cut -d ' ' -f 2)"
  if [[ -z "${current_forks_commit}" || -z "${current_forks_tree}" ]]; then
    return
  fi

  updated_forks_tree=$(recursive_remove_from_tree "${fork_path}" "${current_forks_tree}")
  if [[ -z "${updated_forks_tree}" ]]; then
    updated_forks_tree=$(git hash-object -t tree /dev/null)
  fi
  new_forks_commit=$(git commit-tree -p "${current_forks_commit}" -m "Removing the fork ${name}" "${updated_forks_tree}")
  git update-ref "refs/devtools/forks" "${new_forks_commit}" "${current_forks_commit}"
}

function show_fork_from {
  name="${1}"
  forks_ref="${2}"

  name_hash="$(echo "${name}" | git hash-object -w --stdin)"
  fork_path="${name_hash:0:1}/${name_hash:1:1}/${name_hash:2}"

  fork_tree="$(git ls-tree -r "${forks_ref}" "${fork_path}" 2>/dev/null || true)"
  if [[ -z "${fork_tree}" ]]; then
    echo "Fork ${name} not found" >&2
    exit 2
  fi

  url_hashes="$(echo "${fork_tree}" | grep '/URLS/' | cut -d '/' -f 5)"
  refspec_hashes="$(echo "${fork_tree}" | grep '/REFSPECS/' | cut -d '/' -f 5)"

  echo "[fork \"${name}\"]"
  for url_hash in ${url_hashes}; do
    url="$(git cat-file -p "${url_hash}" 2>/dev/null || true)"
    if [[ -n "${url}" ]]; then
      echo "${tab}url = ${url}"
    fi
  done
  for refspec_hash in ${refspec_hashes}; do
    refspec="$(git cat-file -p "${refspec_hash}" 2>/dev/null || true)"
    if [[ -n "${refspec}" ]]; then
      echo "${tab}fetch = ${refspec}"
    fi
  done
}

function list_from {
  if [[ -z "$(git show-ref ${1})" ]]; then
    return
  fi
  forks_tree="$(git ls-tree -r "${1}")"
  while read tree_line; do
    path=$(echo "${tree_line}" | cut -d $'\t' -f 2)
    if [[ "${path}" =~ ^.*/URLS/.*$ ]]; then
      name_path="$(echo ${path} | cut -d "/" -f 1,2,3)"
      name_hash="${name_path//\/}"
      blob="$(echo "${path}" | cut -d '/' -f 5)"
      name="$(git cat-file -p "${name_hash}" 2>/dev/null || true)"
      url="$(git cat-file -p "${blob}" 2>/dev/null || true)"
      # Only list forks if the name and URL could be found and the name had neither slashes nor tabs
      if [[ -n "${name}" && -n "${url}" && ("${name}" == "${name//\//}") && ("${name}" == "${name//${tab}/}")]]; then
        echo "${name}${tab}${url}"
      fi
    fi
  done < <(echo "${forks_tree}")
}

function remote_devtools_ref_prefix {
  echo "refs/remoteDevtools/$(echo "${1}" | git hash-object --stdin)/"
}

function fetch_from {
  git fetch "${1}" "+refs/devtools/*:${2}*"
}

function list {
  if [[ -z "${1}" ]]; then
    list_from "refs/devtools/forks"
  else
    remote_ref_prefix=$(remote_devtools_ref_prefix "${1}")
    fetch_from "${1}" "${remote_ref_prefix}"
    list_from "${remote_ref_prefix}forks"
  fi
}

function pull_from {
  remote_ref_prefix=$(remote_devtools_ref_prefix)
  remote_forks_ref="${remote_ref_prefix}forks"
  fetch_from "${1}" "${remote_ref_prefix}"
  if [[ -z "$(git show-ref ${remote_forks_ref})" ]]; then
    # We have no remote forks to merge... just return
    return
  fi
  if [[ -z "$(git show-ref refs/devtools/forks)" ]]; then
    # We have no local forks to merge... just update the ref
    git update-ref "refs/devtools/forks" "${remote_forks_ref}"
    return
  fi

  maindir=$(pwd)
  merge_dir=$(mktemp -d 2>/dev/null || mktemp -d -t 'git-fork-merge')
  trap "{ cd ${maindir}; {git worktree remove --force ${merge_dir} 2>/dev/null || true}; rm -rf ${merge_dir}; }" EXIT

  git worktree add "${merge_dir}" "refs/devtools/forks"
  git merge --commit --allow-unrelated-histories --no-edit -s recursive -X ours "${remote_forks_ref}"
}

function push_to {
  if [[ -z "$(git show-ref refs/devtools/forks)" ]]; then
    # We have nothing to push
    return
  fi
  git push "${1}" "+refs/devtools/forks:refs/devtools/forks"
}

function show {
  name="${1}"
  if [[ -z "${name}" ]]; then
    echo "You must specify the fork to show" >&2
    echo "" >&2
    echo "Usage: git fork show <name> [<remote>]" >&2
    exit 1
  fi

  if [[ -z "${2}" ]]; then
    show_fork_from "${name}" "refs/devtools/forks"
  else
    remote_ref_prefix=$(remote_devtools_ref_prefix "${2}")
    fetch_from "${2}" "${remote_ref_prefix}"
    show_fork_from "${name}" "${remote_ref_prefix}forks"
  fi
}

command="${1:-list}"
case "${command}" in
  add)
    owners=""
    while [[ "${2}" == "-o" ]]; do
      shift
      owners="${owners} ${2}"
      shift
    done
    add_fork "${2}" "${3}" "${owners}"
    ;;
  list)
    list "${2}"
    ;;
  pull)
    pull_from "${2}"
    ;;
  push)
    push_to "${2}"
    ;;
  remove)
    remove_fork "${2}"
    ;;
  show)
    show "${2}" "${3}"
    ;;
  *)
    echo "Unknown command: ${command}" >&2
    exit 1
esac
